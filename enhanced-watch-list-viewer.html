<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Watch Address Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/4.0.1-alpha.5/web3.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        .search {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }
        .tag {
            display: inline-block;
            padding: 4px 8px;
            background: #e9ecef;
            border-radius: 4px;
            margin-right: 4px;
            font-size: 0.9em;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .stat-title {
            color: #6c757d;
            font-size: 0.9em;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: 600;
            margin-top: 5px;
        }
        .address-type {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .type-btc { background: #fff2cc; }
        .type-erc20 { background: #e6f3ff; }
        .type-bep20 { background: #f2e6ff; }
        .dropzone {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            margin-bottom: 20px;
        }
        .balance {
            font-family: monospace;
            font-weight: 500;
        }
        .token-name {
            font-weight: 500;
            color: #2c3e50;
        }
        .file-format {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .file-format pre {
            background: #fff;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .refresh-btn {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .refresh-btn:hover {
            background: #0056b3;
        }
        .loading {
            opacity: 0.5;
            pointer-events: none;
        }
        .error {
            color: #dc3545;
            font-size: 0.9em;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Enhanced Watch Address Viewer</h1>
            <button id="refreshBalances" class="refresh-btn">Refresh Balances</button>
        </div>
        
        <div class="dropzone" id="dropzone">
            <p>Drag and drop your watch address file here or click to select</p>
            <input type="file" id="fileInput" style="display: none">
        </div>

        <div class="file-format">
            <h3>Expected File Format:</h3>
            <pre>
# Format: address    token    comment
# Example:
1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa    BTC    Satoshi's Genesis Address
0x742d35Cc6634C0532925a3b844Bc454e4438f44e    ETH    Ethereum Foundation
0xdAC17F958D2ee523a2206206994597C13D831ec7    USDT    USDT Contract</pre>
        </div>

        <div id="content" style="display: none">
            <div class="stats" id="stats">
                <!-- Stats will be populated here -->
            </div>

            <div class="filters">
                <div class="filter-group">
                    <label for="search">Search</label>
                    <input type="text" id="search" class="search" placeholder="Search addresses...">
                </div>
                <div class="filter-group">
                    <label for="typeFilter">Protocol</label>
                    <select id="typeFilter">
                        <option value="">All Protocols</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="tokenFilter">Token</label>
                    <select id="tokenFilter">
                        <option value="">All Tokens</option>
                    </select>
                </div>
            </div>

            <table id="addressTable">
                <thead>
                    <tr>
                        <th>Protocol</th>
                        <th>Address</th>
                        <th>Token</th>
                        <th>Comment</th>
                        <th>Current Balance</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Table content will be populated here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let addresses = [];
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const content = document.getElementById('content');
        const refreshButton = document.getElementById('refreshBalances');

        function detectAddressType(token) {
            const tokenLower = token.toLowerCase();
            if (tokenLower === 'btc') return 'BTC';
            const erc20Tokens = ['eth', 'usdt', 'usdc', 'xlm', 'aave', 'link', 'uni', 'pol', 'fet', 'arb', 'grt', 'weth'];
            if (erc20Tokens.includes(tokenLower)) return 'ERC20';
            if (tokenLower === 'bnb') return 'BEP20';
            if (tokenLower === 'trx') return 'TRC20';
            if (tokenLower === 'ada') return 'ADA';
            if (tokenLower === 'sol' || tokenLower === 'ray') return 'SPL';
            if (tokenLower === 'near') return 'NEAR';
            if (tokenLower === 'theta') return 'THETA';
            return 'Unknown';
        }

        async function fetchCurrentBalance(address, token) {
            try {
                const type = detectAddressType(token);
                
                if (type === 'BTC') {
                    // Use a Bitcoin API (e.g. Blockstream, BlockCypher)
                    const response = await fetch(`https://blockstream.info/api/address/${address}`);
                    const data = await response.json();
                    return (data.chain_stats.funded_txo_sum - data.chain_stats.spent_txo_sum) / 100000000;
                }
                
                if (type === 'ERC20') {
                    const web3 = new Web3('https://rpc.ankr.com/eth');
                    
                    if (token === 'ETH') {
                        const balance = await web3.eth.getBalance(address);
                        return web3.utils.fromWei(balance, 'ether');
                    } else {
                        // For ERC20 tokens
                        const tokenContracts = {
                            'USDT': {
                                address: '0xdac17f958d2ee523a2206206994597c13d831ec7',
                                decimals: 6
                            },
                            'USDC': {
                                address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
                                decimals: 6
                            },
                            'AAVE': {
                                address: '0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9',
                                decimals: 18
                            },
                            'LINK': {
                                address: '0x514910771AF9Ca656af840dff83E8264EcF986CA',
                                decimals: 18
                            },
                            'UNI': {
                                address: '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984',
                                decimals: 18
                            },
                            'POL': {
                                address: '0x9992eC3cF6A55b00978cdDF2b27BC6882d88D1eC',
                                decimals: 18
                            },
                            'FET': {
                                address: '0xaea46A60368A7bD060eec7DF8CBa43b7EF41Ad85',
                                decimals: 18
                            },
                            'ARB': {
                                address: '0xB50721BCf8d664c30412Cfbc6cf7a15145234ad1',
                                decimals: 18
                            },
                            'GRT': {
                                address: '0xc944E90C64B2c07662A292be6244BDf05Cda44a7',
                                decimals: 18
                            },
                            'WETH': {
                                address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
                                decimals: 18
                            }
                        };
                        
                        const tokenInfo = tokenContracts[token];
                        if (!tokenInfo) return 'Unsupported Token';
                        
                        const contract = new web3.eth.Contract([
                            {
                                "constant": true,
                                "inputs": [{"name": "_owner", "type": "address"}],
                                "name": "balanceOf",
                                "outputs": [{"name": "balance", "type": "uint256"}],
                                "type": "function"
                            }
                        ], tokenInfo.address);
                        
                        const balance = await contract.methods.balanceOf(address).call();
                        return balance / Math.pow(10, tokenInfo.decimals);
                    }
                }

                if (type === 'BEP20') {
                    const web3 = new Web3('https://bsc-dataseed1.binance.org:443');
                    const balance = await web3.eth.getBalance(address);
                    return web3.utils.fromWei(balance, 'ether');
                }

                if (type === 'TRC20') {
                    // Use TRON Grid API
                    const response = await fetch(`https://api.trongrid.io/v1/accounts/${address}`);
                    const data = await response.json();

                    if (token === 'TRX') {
                        return data.data[0].balance / 1000000;
                    } else if (token === 'USDT') {
                        const trc20Tokens = data.data[0].trc20 || [];
                        const usdtContract = 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t';
                        const usdtBalance = trc20Tokens[usdtContract];
                        return usdtBalance ? usdtBalance / 1000000 : 0;
                    }
                }

                if (type === 'ADA') {
                    try {
                        // Use Cardano Blockchain Explorer API
                        const response = await fetch(`https://cardano-mainnet.blockfrost.io/api/v0/addresses/${address}`, {
                            headers: {
                                'project_id': 'mainnetXXXXXXXXXXXXXX' // Replace with your Blockfrost API key
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        // Check if amount exists and has entries
                        if (!data.amount || data.amount.length === 0) {
                            return 0;
                        }
                        
                        // Find the ADA balance (lovelace entry)
                        const lovelaceEntry = data.amount.find(entry => !entry.unit || entry.unit === 'lovelace');
                        if (!lovelaceEntry) {
                            return 0;
                        }
                        
                        return lovelaceEntry.quantity / 1000000; // Convert lovelace to ADA
                    } catch (cardanoError) {
                        console.error('Cardano balance fetch error:', cardanoError);
                        return 'API Error';
                    }
                }

                if (type === 'SPL') {
                    try {
                        // Use Solana RPC API
                        const response = await fetch('https://api.mainnet-beta.solana.com', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                "jsonrpc": "2.0",
                                "id": 1,
                                "method": "getBalance",
                                "params": [address]
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (data.result && data.result.value !== undefined) {
                            return data.result.value / 1000000000; // Convert lamports to SOL
                        }
                        return 'Error';
                    } catch (solanaError) {
                        console.error('Solana balance fetch error:', solanaError);
                        return 'API Error';
                    }
                }

                if (type === 'NEAR') {
                    try {
                        // Use NEAR RPC API
                        const response = await fetch('https://rpc.mainnet.near.org', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                "jsonrpc": "2.0",
                                "id": "dontcare",
                                "method": "query",
                                "params": {
                                    "request_type": "view_account",
                                    "finality": "final",
                                    "account_id": address
                                }
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (data.result && data.result.amount) {
                            return data.result.amount / 1e24; // Convert yoctoNEAR to NEAR
                        }
                        return 'Error';
                    } catch (nearError) {
                        console.error('NEAR balance fetch error:', nearError);
                        return 'API Error';
                    }
                }

                if (type === 'THETA') {
                    try {
                        // Use Theta Explorer API
                        const response = await fetch(`https://explorer.thetatoken.org:8443/api/account/${address}`);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (data.body && data.body.balance !== undefined) {
                            return data.body.balance / 1e18; // Convert Wei to THETA
                        }
                        return 'Error';
                    } catch (thetaError) {
                        console.error('Theta balance fetch error:', thetaError);
                        return 'API Error';
                    }
                }
                
                return 'Unsupported';
            } catch (error) {
                console.error('Error fetching balance:', error);
                return 'Error';
            }
        }

        function parseAddressFile(text) {
            const lines = text.split('\n');
            const parsedAddresses = [];
            
            for (const line of lines) {
                if (line.trim() && !line.startsWith('#')) {
                    const [address, token, ...commentParts] = line.split(/\s+/);
                    const comment = commentParts.join(' ');
                    
                    if (address && token) {
                        parsedAddresses.push({
                            address: address.trim(),
                            token: token.trim(),
                            comment: comment.trim(),
                            type: detectAddressType(token.trim()),
                            currentBalance: '...'
                        });
                    } else {
                        console.warn('Skipping invalid line:', line);
                    }
                }
            }
            
            return parsedAddresses;
        }

        async function updateBalances() {
            const tbody = document.querySelector('#addressTable tbody');
            tbody.classList.add('loading');
            refreshButton.disabled = true;

            for (const addr of addresses) {
                addr.currentBalance = await fetchCurrentBalance(addr.address, addr.token);
                updateTable(filterAddresses());
            }

            tbody.classList.remove('loading');
            refreshButton.disabled = false;
        }

        function updateStats() {
            const stats = document.getElementById('stats');
            const typeCount = _.countBy(addresses, 'type');
            const tokenCount = _.countBy(addresses, 'token');
            
            stats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-title">Total Entries</div>
                    <div class="stat-value">${addresses.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Unique Addresses</div>
                    <div class="stat-value">${new Set(addresses.map(a => a.address)).size}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Token Types</div>
                    <div class="stat-value">${Object.keys(tokenCount).length}</div>
                </div>
                ${Object.entries(typeCount).map(([type, count]) => `
                    <div class="stat-card">
                        <div class="stat-title">${type}</div>
                        <div class="stat-value">${count}</div>
                    </div>
                `).join('')}
            `;
        }

        function updateFilters() {
            const typeFilter = document.getElementById('typeFilter');
            const tokenFilter = document.getElementById('tokenFilter');
            
            const types = _.uniq(addresses.map(addr => addr.type));
            const tokens = _.uniq(addresses.map(addr => addr.token));
            
            typeFilter.innerHTML = '<option value="">All Protocols</option>' + 
                types.map(type => `<option value="${type}">${type}</option>`).join('');

            tokenFilter.innerHTML = '<option value="">All Tokens</option>' + 
                tokens.map(token => `<option value="${token}">${token}</option>`).join('');
        }

        function updateTable(filtered = addresses) {
            const tbody = document.querySelector('#addressTable tbody');
            tbody.innerHTML = filtered.map(addr => `
                <tr>
                    <td><span class="address-type type-${addr.type.toLowerCase().replace(/\s+/g, '-')}">${addr.type}</span></td>
                    <td>${addr.address}</td>
                    <td class="token-name">${addr.token}</td>
                    <td>${addr.comment}</td>
                    <td class="balance">${addr.currentBalance}</td>
                </tr>
            `).join('');
        }

        function filterAddresses() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            const selectedType = document.getElementById('typeFilter').value;
            const selectedToken = document.getElementById('tokenFilter').value;
            
            return addresses.filter(addr => {
                const matchesSearch = !searchTerm || 
                    addr.address.toLowerCase().includes(searchTerm) ||
                    addr.comment.toLowerCase().includes(searchTerm);
                const matchesType = !selectedType || addr.type === selectedType;
                const matchesToken = !selectedToken || addr.token === selectedToken;
                
                return matchesSearch && matchesType && matchesToken;
            });
        }

        // Event Listeners
        dropzone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    addresses = parseAddressFile(event.target.result);
                    content.style.display = 'block';
                    updateStats();
                    updateFilters();
                    updateTable();
                    updateBalances();
                };
                reader.readAsText(file);
            }
        });

        // Add drag and drop support
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.style.borderColor = '#007bff';
        });

        dropzone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.style.borderColor = '#ddd';
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.style.borderColor = '#ddd';
            
            const file = e.dataTransfer.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    addresses = parseAddressFile(event.target.result);
                    content.style.display = 'block';
                    updateStats();
                    updateFilters();
                    updateTable();
                    updateBalances();
                };
                reader.readAsText(file);
            }
        });

        // Add filter event listeners
        document.getElementById('search').addEventListener('input', () => updateTable(filterAddresses()));
        document.getElementById('typeFilter').addEventListener('change', () => updateTable(filterAddresses()));
        document.getElementById('tokenFilter').addEventListener('change', () => updateTable(filterAddresses()));

        // Add refresh button listener
        refreshButton.addEventListener('click', updateBalances);
    </script>
</body>
</html>