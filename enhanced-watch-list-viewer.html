<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Watch Address Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/4.0.1-alpha.5/web3.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        .search {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }
        .tag {
            display: inline-block;
            padding: 4px 8px;
            background: #e9ecef;
            border-radius: 4px;
            margin-right: 4px;
            font-size: 0.9em;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .stat-title {
            color: #6c757d;
            font-size: 0.9em;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: 600;
            margin-top: 5px;
        }
        .address-type {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .type-btc { background: #fff2cc; }
        .type-eth { background: #e6f3ff; }
        .type-segwit { background: #f2e6ff; }
        .dropzone {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            margin-bottom: 20px;
        }
        .balance {
            font-family: monospace;
            font-weight: 500;
        }
        .token-name {
            font-weight: 500;
            color: #2c3e50;
        }
        .file-format {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .file-format pre {
            background: #fff;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .refresh-btn {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .refresh-btn:hover {
            background: #0056b3;
        }
        .loading {
            opacity: 0.5;
            pointer-events: none;
        }
        .error {
            color: #dc3545;
            font-size: 0.9em;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Enhanced Watch Address Viewer</h1>
            <button id="refreshBalances" class="refresh-btn">Refresh Balances</button>
        </div>
        
        <div class="dropzone" id="dropzone">
            <p>Drag and drop your watch address file here or click to select</p>
            <input type="file" id="fileInput" style="display: none">
        </div>

        <div class="file-format">
            <h3>Expected File Format:</h3>
            <pre>
# Format: address    token_symbol    amount    label    tags
# Example:
1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa    BTC    12.5    First mined    #historical #mining
0x742d35Cc6634C0532925a3b844Bc454e4438f44e    ETH    5.2    Trading wallet    #trading
0x742d35Cc6634C0532925a3b844Bc454e4438f44e    USDT    1000    Trading wallet    #trading
bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4    BTC    0.5    Cold storage    #savings</pre>
        </div>

        <div id="content" style="display: none">
            <div class="stats" id="stats">
                <!-- Stats will be populated here -->
            </div>

            <div class="filters">
                <div class="filter-group">
                    <label for="search">Search</label>
                    <input type="text" id="search" class="search" placeholder="Search addresses or labels...">
                </div>
                <div class="filter-group">
                    <label for="typeFilter">Address Type</label>
                    <select id="typeFilter">
                        <option value="">All Types</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="tokenFilter">Token</label>
                    <select id="tokenFilter">
                        <option value="">All Tokens</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="tagFilter">Tags</label>
                    <select id="tagFilter">
                        <option value="">All Tags</option>
                    </select>
                </div>
            </div>

            <table id="addressTable">
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Address</th>
                        <th>Token</th>
                        <th>Amount</th>
                        <th>Current Balance</th>
                        <th>Label</th>
                        <th>Tags</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Table content will be populated here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let addresses = [];
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const content = document.getElementById('content');
        const refreshButton = document.getElementById('refreshBalances');

        function detectAddressType(address) {
            if (address.startsWith('1')) return 'Bitcoin Legacy';
            if (address.startsWith('3')) return 'Bitcoin SegWit';
            if (address.startsWith('bc1')) return 'Bitcoin Native SegWit';
            if (address.toLowerCase().startsWith('0x')) return 'Ethereum';
            return 'Unknown';
        }

        async function fetchCurrentBalance(address, token) {
            try {
                // This is a mock implementation - in real use, you'd want to:
                // 1. Use proper blockchain node endpoints
                // 2. Handle rate limiting
                // 3. Implement proper error handling
                // 4. Add support for more chains and tokens
                
                if (token === 'ETH') {
                    const web3 = new Web3('https://mainnet.infura.io/v3/YOUR-PROJECT-ID');
                    const balance = await web3.eth.getBalance(address);
                    return web3.utils.fromWei(balance, 'ether');
                }
                
                // Mock responses for demo
                const mockBalances = {
                    'BTC': '0.00',
                    'USDT': '0.00',
                    'ETH': '0.00'
                };
                
                return mockBalances[token] || '0.00';
            } catch (error) {
                console.error('Error fetching balance:', error);
                return 'Error';
            }
        }

        function parseAddressFile(text) {
            const lines = text.split('\n');
            const parsedAddresses = [];
            
            for (const line of lines) {
                if (line.trim() && !line.startsWith('#')) {
                    const [address, token, amount, ...rest] = line.split('\t');
                    const labelAndTags = rest.join('\t').trim();
                    const tags = (labelAndTags.match(/#\w+/g) || []).map(tag => tag.slice(1));
                    const label = labelAndTags.replace(/#\w+/g, '').trim();
                    
                    parsedAddresses.push({
                        address: address.trim(),
                        token: token.trim(),
                        amount: parseFloat(amount) || 0,
                        label,
                        tags,
                        type: detectAddressType(address.trim()),
                        currentBalance: '...'
                    });
                }
            }
            
            return parsedAddresses;
        }

        async function updateBalances() {
            const tbody = document.querySelector('#addressTable tbody');
            tbody.classList.add('loading');
            refreshButton.disabled = true;

            for (const addr of addresses) {
                addr.currentBalance = await fetchCurrentBalance(addr.address, addr.token);
                updateTable(filterAddresses());
            }

            tbody.classList.remove('loading');
            refreshButton.disabled = false;
        }

        function updateStats() {
            const stats = document.getElementById('stats');
            const typeCount = _.countBy(addresses, 'type');
            const tokenCount = _.countBy(addresses, 'token');
            const totalTags = addresses.reduce((sum, addr) => sum + addr.tags.length, 0);
            
            stats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-title">Total Entries</div>
                    <div class="stat-value">${addresses.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Unique Addresses</div>
                    <div class="stat-value">${new Set(addresses.map(a => a.address)).size}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Token Types</div>
                    <div class="stat-value">${Object.keys(tokenCount).length}</div>
                </div>
                ${Object.entries(typeCount).map(([type, count]) => `
                    <div class="stat-card">
                        <div class="stat-title">${type}</div>
                        <div class="stat-value">${count}</div>
                    </div>
                `).join('')}
            `;
        }

        function updateFilters() {
            const typeFilter = document.getElementById('typeFilter');
            const tagFilter = document.getElementById('tagFilter');
            const tokenFilter = document.getElementById('tokenFilter');
            
            const types = _.uniq(addresses.map(addr => addr.type));
            const tags = _.uniq(addresses.flatMap(addr => addr.tags));
            const tokens = _.uniq(addresses.map(addr => addr.token));
            
            typeFilter.innerHTML = '<option value="">All Types</option>' + 
                types.map(type => `<option value="${type}">${type}</option>`).join('');
            
            tagFilter.innerHTML = '<option value="">All Tags</option>' + 
                tags.map(tag => `<option value="${tag}">${tag}</option>`).join('');

            tokenFilter.innerHTML = '<option value="">All Tokens</option>' + 
                tokens.map(token => `<option value="${token}">${token}</option>`).join('');
        }

        function updateTable(filtered = addresses) {
            const tbody = document.querySelector('#addressTable tbody');
            tbody.innerHTML = filtered.map(addr => `
                <tr>
                    <td><span class="address-type type-${addr.type.toLowerCase().replace(/\s+/g, '-')}">${addr.type}</span></td>
                    <td>${addr.address}</td>
                    <td class="token-name">${addr.token}</td>
                    <td class="balance">${addr.amount.toFixed(8)}</td>
                    <td class="balance">${addr.currentBalance}</td>
                    <td>${addr.label}</td>
                    <td>${addr.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}</td>
                </tr>
            `).join('');
        }

        function filterAddresses() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            const selectedType = document.getElementById('typeFilter').value;
            const selectedTag = document.getElementById('tagFilter').value;
            const selectedToken = document.getElementById('tokenFilter').value;
            
            return addresses.filter(addr => {
                const matchesSearch = !searchTerm || 
                    addr.address.toLowerCase().includes(searchTerm) || 
                    addr.label.toLowerCase().includes(searchTerm);
                const matchesType = !selectedType || addr.type === selectedType;
                const matchesTag = !selectedTag || addr.tags.includes(selectedTag);
                const matchesToken = !selectedToken || addr.token === selectedToken;
                
                return matchesSearch && matchesType && matchesTag && matchesToken;
            });
        }

        // Event Listeners
        dropzone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onloa